# --
# - inputs for saving the data -
savepath <- "/Users/jvb740/MarieCurie_Work/CellCounting_TaskForce/FlowCytometryAnalysis/Results"
savename <- NULL
# --
source(file.path(functionpath, function_file))
files <- list.files(datapath)
files <- files[grepl("*.fcs", files)]
fcsFileList <- lapply(file.path(datapath, files), read.FCS, transformation=FALSE)
# fcsFileList <- lapply(file.path(datapath, files), read.FCS, transformation=FALSE, column.pattern = "-W|-H", invert.pattern = TRUE)
names(fcsFileList) <- files
ParameterValuesList <- lapply(fcsFileList, extract_parameter_keywords_from_flowFrame)
# -- test that at least all but BS and MS are identical --
ParameterValuesList_Restricted <- lapply(ParameterValuesList, function(DF){
DF <- DF[c("N", "R", "B", "E", "V", "G", "DISPLAY")]
rownames(DF) <- NULL
DF
})
if (length(unique(ParameterValuesList_Restricted))) {
PrintList <- ParameterValuesList[[1]]
} else {
PrintList <- ParameterValuesList
}
PrintList
nonParameterValuesList <- lapply(fcsFileList, extract_all_non_parameter_keywords_from_flowFrame)
# - reorder based on the wells -
WellIDs <- vapply(nonParameterValuesList, function(DF){DF$Value[DF$Keyword == "WELL ID"]}, character(1))
fcsFileList <- fcsFileList[order(WellIDs)]
# --
# -- check that the length are equal (better would be to check that all Keywords are identical) --
if(length(unique(vapply(nonParameterValuesList, nrow, numeric(1)))) == 1) {
nPV_DF <- do.call("cbind", nonParameterValuesList)
nPV_DF <- nPV_DF[, c(1, seq(2, ncol(nPV_DF), by = 2))]
# -- reorder based on WellIDs --
nPV_DF <- dplyr::select(nPV_DF, Keword = 1, (order(WellIDs)+1))
# ----
} else {
nPV_DF <- NULL
}
View(nPV_DF)
fs <- as(fcsFileList, "flowSet")
KeywordTable <- as.data.frame(keyword(fs, c("$TOT", "$PAR", "TUBE NAME", "THRESHOLD", "$DATE", "EXPORT TIME", "$BTIM", "$ETIM")))
KeywordTable <- cbind(data.frame(Index = 1:nrow(KeywordTable), Sample = rownames(KeywordTable)), KeywordTable)
rownames(KeywordTable) <- NULL
# change sample Names
# flowWorkspace::sampleNames(fs) <- paste(Prefix, fs@phenoData@data$well, fs@phenoData@data$SRC, sep = "_")
#
# rownames(KeywordTable) <- flowWorkspace::sampleNames(fs)
KeywordTable$`$BTIM` <- hms(KeywordTable$`$BTIM`)
KeywordTable$`$ETIM` <- hms(KeywordTable$`$ETIM`)
KeywordTable$RecTime_sec <- as.numeric(as.duration(KeywordTable$`$ETIM`- KeywordTable$`$BTIM`), "seconds")
# - new add the run time from the exprs data -
Maximums <- as.data.frame(fsApply(fs, each_col, max))
Minimums <- as.data.frame(fsApply(fs, each_col, min))
KeywordTable$RunTime_sec <- (Maximums$Time - Minimums$Time)/100
# --
View(KeywordTable)
# Determine Minimum values of the different parameters in the different samples
MatrixList <- lapply(1:length(fs), FUN = function(x){exprs(fs[[x]])})
names(MatrixList) <- flowWorkspace::sampleNames(fs)
MinimumsAbove0 <- t(sapply(MatrixList, function(x){apply(x, 2, function(y) min(y[y>0]))}))
# MinimumsAbove0 <- fsApply(fs, each_col, function(x){min(x[x>0])})
BigDF <- as.data.frame(do.call("rbind", MatrixList))
Discretized <- lapply(BigDF, function(x){head(sort(unique(x[x>0])), 10)})
Discretized <- do.call("cbind", Discretized)
rm(BigDF)
View(Minimums)
# Determine Minimum values of the different parameters in the different samples
knitr::kable(Minimums, caption = "Minimums")
knitr::kable(MinimumsAbove0, caption = "Minimums above 0")
knitr::kable(Maximums, caption = "Maximums")
knitr::kable(Discretized, caption = "Discretized steps above 0")
gs <- GatingSet(fs) # also GatingSets are S4 objects
Gate.Area <- rectangleGate(filterId = "Area", list("FSC-A" = c(FSC.A.low, FSC.A.high), "SSC-A" = c(SSC.A.low, SSC.A.high)))
# add the gate to the gs
add(gs, Gate.Area, parent = "root")
# gate the data
recompute(gs)
gatingStats <- gs.Stats(gs)
knitr::kable(gatingStats[[1]], caption = "after gate 1")
knitr::kable(gatingStats[[2]], caption = "after gate 1")
TrL <- FC.geom_hex(fs = getData(gs, "/Area"), x = "Pacific Blue-A", y = "FSC-A", bins = bins, co.fix = TRUE, xlimits = c(0.1, 300000), ylimits = c(.1,300000), trans = "log10", colPalette = NULL, ncolors = 10)
# - geom_point alternatives, are slower and with high enough bins FC.geom_hex contains almost all info -
# TrL_p <- FC.geom_point(fs = getData(gs, "/Area"), x = "Pacific Blue-A", y = "FSC-A", pch = ".", co.fix = TRUE, xlimits = c(0.1, 300000), ylimits = c(.1,300000), trans = "log10", nbin = 150)
# #
# # # -- even slower but with legend, so I prefer this point alternative --
# TrL_p <- FC.geom_point_kernel(fs = getData(gs, "/Area"), x = "Pacific Blue-A", y = "FSC-A", pch = ".", co.fix = TRUE, xlimits = c(0.1, 300000), ylimits = c(.1,300000), trans = "log10", colPalette = viridis, nbin = 70, ncolors = 10)
# # # ----
# --
#Poly <- data.frame(x = c(100, 15000, 15000, 2000, 800, 200), y = c(100, 100, 25000, 25000, 7000, 800))
TrL_Poly <- plotPolygon(TrL = TrL, polyDF = Poly)
TrL_Poly[[3]]
TrL_Poly[[11]]
TrL_Poly[[2]]
TrL_Poly[[10]]
TrL_Poly[[3]]
TrL_Poly[[11]]
matr <- as.matrix(Poly)
colnames(matr) <- c("Pacific Blue-A", "FSC-A")
Gate.Poly <- polygonGate(matr, filterId = "Cells")
# add the gate to the gs
add(gs, Gate.Poly, parent = "/Area")
# gate the data
recompute(gs)
gatingStats <- gs.Stats(gs)
TrL <- FC.geom_hex(fs = getData(gs, "/Area"), x = "PE-A", y = "FSC-A", bins = bins, co.fix = TRUE, xlimits = c(0.1, 300000), ylimits = c(.1,300000), trans = "log10", colPalette = NULL, ncolors = 10)
#TrL <- FC.geom_hex(fs = getData(gs, "/Area"), x = "PE-A", y = "Pacific Blue-A", bins = bins, co.fix = TRUE, xlimits = c(0.1, 300000), ylimits = c(.1,300000), trans = "log10", colPalette = NULL, ncolors = 10)
# - geom_point alternatives, are slower and with high enough bins FC.geom_hex contains almost all info -
# TrL_p <- FC.geom_point(fs = getData(gs, "/Area"), x = "PE-A", y = "FSC-A", pch = ".", co.fix = TRUE, xlimits = c(0.1, 300000), ylimits = c(.1,300000), trans = "log10", nbin = 150)
#
# # -- even slower but with legend, so I prefer this point alternative --
# TrL_p <- FC.geom_point_kernel(fs = getData(gs, "/Area"), x = "PE-A", y = "FSC-A", pch = ".", co.fix = TRUE, xlimits = c(0.1, 300000), ylimits = c(.1,300000), trans = "log10", colPalette = viridis, nbin = 70, ncolors = 10)
# # ----
# --
# Poly_Beads <- data.frame(x = c(20000, 260000, 260000, 20000), y = c(30000, 30000, 220000, 220000))
TrL_Poly <- plotPolygon(TrL = TrL, polyDF = Poly_Beads)
TrL_Poly[[1]]
plot(gs)
matr <- as.matrix(Poly_Beads)
colnames(matr) <- c("PE-A", "FSC-A")
Gate.Poly <- polygonGate(matr, filterId = "Beads")
# add the gate to the gs
add(gs, Gate.Poly, parent = "/Area")
# gate the data
recompute(gs)
gatingStats <- gs.Stats(gs)
TrL <- FC.geom_hex(fs = getData(gs, "/Area"), x = "PE-A", y = "Pacific Blue-A", bins = bins, co.fix = TRUE, xlimits = c(0.1, 300000), ylimits = c(.1,300000), trans = "log10", colPalette = NULL, ncolors = 10)
#TrL <- FC.geom_hex(fs = getData(gs, "/Area"), x = "PE-A", y = "Pacific Blue-A", bins = bins, co.fix = TRUE, xlimits = c(0.1, 300000), ylimits = c(.1,300000), trans = "log10", colPalette = NULL, ncolors = 10)
# - geom_point alternatives, are slower and with high enough bins FC.geom_hex contains almost all info -
# TrL_p <- FC.geom_point(fs = getData(gs, "/Area"), x = "PE-A", y = "FSC-A", pch = ".", co.fix = TRUE, xlimits = c(0.1, 300000), ylimits = c(.1,300000), trans = "log10", nbin = 150)
#
# # -- even slower but with legend, so I prefer this point alternative --
# TrL_p <- FC.geom_point_kernel(fs = getData(gs, "/Area"), x = "PE-A", y = "FSC-A", pch = ".", co.fix = TRUE, xlimits = c(0.1, 300000), ylimits = c(.1,300000), trans = "log10", colPalette = viridis, nbin = 70, ncolors = 10)
# # ----
# --
# Poly_Beads2 <- data.frame(x = c(20000, 260000, 260000, 20000), y = c(30000, 30000, 220000, 220000))
TrL_Poly <- plotPolygon(TrL = TrL, polyDF = Poly_Beads2)
matr <- as.matrix(Poly_Beads)
colnames(matr) <- c("PE-A", "Pacific Blue-A")
Gate.Poly <- polygonGate(matr, filterId = "Beads2")
# add the gate to the gs
add(gs, Gate.Poly, parent = "/Area")
# gate the data
recompute(gs)
gatingStats <- gs.Stats(gs)
# remember fs is still the completely original flowSet, i.e. fs <- getData(gs, "/root")
fs_beads <- getData(gs, "/Area/Beads")
MatrixList_Beads <- lapply(1:length(fs_beads), FUN = function(x){exprs(fs_beads[[x]])})
names(MatrixList_Beads) <- flowWorkspace::sampleNames(fs_beads)
# - change Matrixes to data frames -
DF_List <- lapply(MatrixList, as.data.frame)
DF_List_Beads <- lapply(MatrixList_Beads, as.data.frame)
# --
# - Goal 1: Event plots where the bead events are marked -
# for this you have to find the bead events in the total events, here is how it can be done:
# -- put bead DF on top of event DF -
DFF_List <- Map(f = rbind, DF_List_Beads, DF_List)
# ----
# -- find duplicated events in combined DFFs --
# takes a bit of time but not brutally long
DFF_List <- lapply(DFF_List, function(DFF){
DFF$Duplicated <- duplicated(DFF)
DFF
})
# ----
# -- remove the bead DFs again --
no_Beads <- sapply(DF_List_Beads, nrow)
DFF_List <- lapply(1:length(DFF_List), function(i){
DFF <- DFF_List[[i]]
DFF <- DFF[(no_Beads[i]+1):nrow(DFF), ]
DFF$Type <- "event"
DFF$Type[DFF$Duplicated] <- "bead"
DFF
})
if (! identical(names(DF_List), names(DF_List_Beads))) {stop("beads and event DF did not fit together")}
names(DFF_List) <- names(DF_List)
#all.equal(sapply(DFF_List, function(DFF){sum(DFF$Duplicated)}), no_Beads)
if(!identical(sapply(DFF_List, nrow), sapply(DF_List, nrow))) {stop("you changed the number of rows here")}
# ----
# -- count the events and change the time to seconds --
DFF_List <- lapply(DFF_List, function(DFF){
DFF$Events <- 1:nrow(DFF)
DFF$Time <- DFF$Time/100
DFF
})
# ----
# -- Do linear fits and record the R2 to add later to the plots --
R_squares_all_events <- lapply(DFF_List, function(DFF){
fit <- lm(Events ~ Time, data = DFF)
summary(fit)$adj.r.square
})
# --
# -- define plot functions --
plot_flow <- function(DF) {
DF2 <- dplyr::filter(DF, Type == "bead")
Tr <- ggplot(DF, aes(x = Time, y = Events))
Tr <- Tr +
geom_point(data = DF2, size = 2, col = "red") +
geom_smooth(method = "lm", se = FALSE) +
geom_line() +
xlab("Time [s]") # +
# theme_bw()
Tr
}
# ----
# -- plot the events --
TrL <- lapply(DFF_List, plot_flow)
TrL <- lapply(1:length(TrL), function(i) {
Tr <- TrL[[i]]
Tr <- Tr +
ggtitle(paste0(names(DFF_List)[i], ": r2: ", round(R_squares_all_events[[i]], 4)))
Tr})
# ----
# --
# - Goal 2: Plot only the arrival of the beads -
# making sure you can deal with samples without beads
no_Beads <- sapply(DF_List_Beads, nrow)
DF_List_Beads <- lapply(MatrixList_Beads, as.data.frame)
# -- count the events and change the time to seconds --
DF_List_Beads <- lapply(DF_List_Beads, function(DFF){
if (nrow(DFF) > 0) {
DFF$Events <- 1:nrow(DFF)
DFF$Time <- DFF$Time/100
DFF
} else {
DFF$Events <- numeric(0)
DFF
}
})
# ----
# -- Do linear fits and record the R2 and the slopes to add later to the plots --
bead_r2_slopes <- lapply(DF_List_Beads, function(DFF){
if (nrow(DFF) > 0) {
fit <- lm(Events ~ Time, data = DFF)
r2 <- summary(fit)$adj.r.square
slope <- fit$coef[2]
data.frame(r2 = r2, slope = slope)
} else {
r2 <- 0
slope <- 0
data.frame(r2 = r2, slope = slope)
}
})
bead_r2_slopes <- do.call("rbind", bead_r2_slopes)
# --
# -- define plot functions --
plot_flow_beads <- function(DF) {
Tr <- ggplot(DF, aes(x = Time, y = Events))
Tr <- Tr +
geom_point(size = 2, col = "red") +
geom_smooth(method = "lm", se = FALSE) +
geom_line() +
xlab("Time [s]") # +
ylab("Beads")
# theme_bw()
Tr
}
# ----
# -- plot the events --
TrL_Beads <- lapply(DF_List_Beads, plot_flow_beads)
TrL_Beads <- lapply(1:length(TrL_Beads), function(i) {
Tr <- TrL_Beads[[i]]
Tr <- Tr +
ggtitle(paste0(names(DF_List_Beads)[i], "; r2: ", round(bead_r2_slopes$r2[i], 4), ", slope: ", round(bead_r2_slopes$slope[i], 3)))
Tr})
# ----
# --
# - combine the two lists so they alternate -
TrLL <- c(rbind(TrL, TrL_Beads))
# --
# - prepare a result DF -
CountFreq <- gs.Stats(gs, gates = getNodes(gs))
res_DF <- cbind(KeywordTable, CountFreq[[1]])
# -- add all the protocol inputs NB: Here the code strictly depends on your input--
res_DF <- dplyr::mutate(res_DF, Beads_av = (Beads + Beads2)/2,
muL_Buffer_per_mg_feces = muL_Buffer_per_mg_feces, muL_supernatant = muL_supernatant,
muL_resuspension = muL_resuspension,  muL_Transfer1 = muL_Transfer1,
muL_Buffer_Transfer1 = muL_Buffer_Transfer1, muL_Transfer2 = muL_Transfer2,
muL_Stain = muL_Stain, beads_conc_permuL = beads_concentration_permuL,
beads_vol_muL = beads_volume_muL, sample_vol_muL = muL_Transfer2 + muL_Stain + beads_volume_muL)
# ----
# -- calculate beads_per_muL in the flow --
res_DF <- dplyr::mutate(res_DF, beads_per_muL_flow = beads_conc_permuL*beads_vol_muL/sample_vol_muL)
# ----
# -- calculate run_volume_muL, flow-rates, and Cells_per_muL_flow --
res_DF <- dplyr::mutate(res_DF, run_volume_muL = Beads_av/beads_per_muL_flow, set_flow_rate_muL_s = set_flow_rate_muL_s, run_volume_muL_FR = RunTime_sec*set_flow_rate_muL_s, flow_muL_per_sec_from_beads = run_volume_muL/RunTime_sec,
bead_slopes = bead_r2_slopes$slope,
flow_muL_per_sec_from_bead_slopes = bead_slopes/beads_per_muL_flow,
Cells_per_muL_flow = Cells/run_volume_muL,
Cells_per_muL_flow_FR = Cells/run_volume_muL_FR)
# ----
# -- Calculate dilution factors --
res_DF <- dplyr::mutate(res_DF, DilFac_Transfer2 = (muL_Transfer2 + muL_Stain + beads_vol_muL)/muL_Transfer2,
DilFac_Transfer1 = (muL_Transfer1 + muL_Buffer_Transfer1)/muL_Transfer1,
DilFac_Transfer0 = muL_resuspension/muL_supernatant,
Cells_per_muL_undiluted = Cells_per_muL_flow * DilFac_Transfer0 * DilFac_Transfer1 * DilFac_Transfer2,
Cells_per_muL_undiluted_FR = Cells_per_muL_flow_FR * DilFac_Transfer0 * DilFac_Transfer1 * DilFac_Transfer2,
Cells_per_mg_feces = Cells_per_muL_undiluted * muL_Buffer_per_mg_feces,
Cells_per_mg_feces_FR = Cells_per_muL_undiluted_FR * muL_Buffer_per_mg_feces,
Cells_per_g_feces = Cells_per_mg_feces * 1000,
Cells_per_g_feces_FR = Cells_per_mg_feces_FR * 1000,
Cells_per_g_feces_e10 = round(Cells_per_g_feces/1e10, 3),
Cells_per_g_feces_e10_FR = round(Cells_per_g_feces_FR/1e10,3))
# ----
# --
res_DF_selected <- dplyr::select(res_DF, Sample, `$TOT`, THRESHOLD, RunTime_sec, Cells, Beads_av, Cells_per_g_feces_e10, Cells_per_g_feces_e10_FR)
View(res_DF)
View(res_DF_selected)
rm(list = ls())
# - define the path to your function file -
functionpath <- "/Users/jvb740/MarieCurie_Work/CellCounting_TaskForce/FlowCytometryAnalysis/Functions_FC"
function_file <- "20190103_FlowCytometry_Functions.R"
# --
# - define the path to the data you want to analyse -
datapath <- "/Users/jvb740/MarieCurie_Work/CellCounting_TaskForce/FlowCytometryAnalysis/Data/20190115_SandraPlate_GtoH"
# --
# - gating Thresholds and Polygons -
# -- for the area gate --
FSC.A.low <- 0.5
FSC.A.high <- Inf
SSC.A.low <- 0.5
SSC.A.high <- Inf
# ----
# -- for gating on Pacific Blue-A FSC-A --
Poly <- data.frame(x = c(100, 15000, 15000, 2000, 800, 200), y = c(100, 100, 25000, 25000, 7000, 800))
# ----
# -- for gating on PE-A FSC-A for the beads --
Poly_Beads <- data.frame(x = c(20000, 260000, 260000, 20000), y = c(30000, 30000, 260000, 260000))
# ----
# -- for gating on PE-A Pacific Blue-A for the beads --
Poly_Beads2 <- data.frame(x = c(20000, 260000, 260000, 20000), y = c(30000, 30000, 260000, 260000))
# ----
# --
# - plotting parameters -
bins <- 300 # defines how "fine" the FC.geom_hex plots will be, the higher the number of bins the more the plot looks like a geom_point plot (a la flowjo) but it's still faster
# --
# - IMPORTANT: Check carefully: Protocol and flow cytometer parameters used -
# -- protocol volumes and concentrations
muL_Buffer_per_mg_feces <- 10 # e.g. 10 when you add 1 ml to 100 mg feces
muL_supernatant <- 150 # the amount of supernatant used after the slow spin, NB: not needed for calculation but record it anyway
muL_resuspension <- 1500 # after the second wash
muL_Transfer1 <- 40
muL_Buffer_Transfer1 <- 760
muL_Transfer2 <- 170
muL_Stain <- 20 # used in Transfer 1
beads_concentration_permuL <- 1022 # in the bought bead tube
beads_volume_muL <- 10 # added in Transfer 2
# ----
# -- flow cytometer settings --
set_flow_rate_muL_s <- 0.5
# ----
# --
# - inputs for saving the data -
savepath <- "/Users/jvb740/MarieCurie_Work/CellCounting_TaskForce/FlowCytometryAnalysis/Results"
savename <- NULL
# --
source(file.path(functionpath, function_file))
files <- list.files(datapath)
files <- files[grepl("*.fcs", files)]
fcsFileList <- lapply(file.path(datapath, files), read.FCS, transformation=FALSE)
# fcsFileList <- lapply(file.path(datapath, files), read.FCS, transformation=FALSE, column.pattern = "-W|-H", invert.pattern = TRUE)
names(fcsFileList) <- files
ParameterValuesList <- lapply(fcsFileList, extract_parameter_keywords_from_flowFrame)
# -- test that at least all but BS and MS are identical --
ParameterValuesList_Restricted <- lapply(ParameterValuesList, function(DF){
DF <- DF[c("N", "R", "B", "E", "V", "G", "DISPLAY")]
rownames(DF) <- NULL
DF
})
if (length(unique(ParameterValuesList_Restricted))) {
PrintList <- ParameterValuesList[[1]]
} else {
PrintList <- ParameterValuesList
}
length(unique(ParameterValuesList_Restricted))
PrintList
ParameterValuesList <- lapply(fcsFileList, extract_parameter_keywords_from_flowFrame)
# -- test that at least all but BS and MS are identical --
ParameterValuesList_Restricted <- lapply(ParameterValuesList, function(DF){
DF <- DF[c("N", "R", "B", "E", "V", "G", "DISPLAY")]
rownames(DF) <- NULL
DF
})
if (length(unique(ParameterValuesList_Restricted)) == 1) {
PrintList <- ParameterValuesList[[1]]
} else {
PrintList <- ParameterValuesList
}
nonParameterValuesList <- lapply(fcsFileList, extract_all_non_parameter_keywords_from_flowFrame)
# - reorder based on the wells -
WellIDs <- vapply(nonParameterValuesList, function(DF){DF$Value[DF$Keyword == "WELL ID"]}, character(1))
fcsFileList <- fcsFileList[order(WellIDs)]
# --
# -- check that the length are equal (better would be to check that all Keywords are identical) --
if(length(unique(vapply(nonParameterValuesList, nrow, numeric(1)))) == 1) {
nPV_DF <- do.call("cbind", nonParameterValuesList)
nPV_DF <- nPV_DF[, c(1, seq(2, ncol(nPV_DF), by = 2))]
# -- reorder based on WellIDs --
nPV_DF <- dplyr::select(nPV_DF, Keword = 1, (order(WellIDs)+1))
# ----
} else {
nPV_DF <- NULL
}
fs <- as(fcsFileList, "flowSet")
KeywordTable <- as.data.frame(keyword(fs, c("$TOT", "$PAR", "TUBE NAME", "THRESHOLD", "$DATE", "EXPORT TIME", "$BTIM", "$ETIM")))
KeywordTable <- cbind(data.frame(Index = 1:nrow(KeywordTable), Sample = rownames(KeywordTable)), KeywordTable)
rownames(KeywordTable) <- NULL
# change sample Names
# flowWorkspace::sampleNames(fs) <- paste(Prefix, fs@phenoData@data$well, fs@phenoData@data$SRC, sep = "_")
#
# rownames(KeywordTable) <- flowWorkspace::sampleNames(fs)
KeywordTable$`$BTIM` <- hms(KeywordTable$`$BTIM`)
KeywordTable$`$ETIM` <- hms(KeywordTable$`$ETIM`)
KeywordTable$RecTime_sec <- as.numeric(as.duration(KeywordTable$`$ETIM`- KeywordTable$`$BTIM`), "seconds")
# - new add the run time from the exprs data -
Maximums <- as.data.frame(fsApply(fs, each_col, max))
Minimums <- as.data.frame(fsApply(fs, each_col, min))
KeywordTable$RunTime_sec <- (Maximums$Time - Minimums$Time)/100
# --
# Determine Minimum values of the different parameters in the different samples
MatrixList <- lapply(1:length(fs), FUN = function(x){exprs(fs[[x]])})
names(MatrixList) <- flowWorkspace::sampleNames(fs)
MinimumsAbove0 <- t(sapply(MatrixList, function(x){apply(x, 2, function(y) min(y[y>0]))}))
# MinimumsAbove0 <- fsApply(fs, each_col, function(x){min(x[x>0])})
BigDF <- as.data.frame(do.call("rbind", MatrixList))
Discretized <- lapply(BigDF, function(x){head(sort(unique(x[x>0])), 10)})
Discretized <- do.call("cbind", Discretized)
rm(BigDF)
View(KeywordTable)
gs <- GatingSet(fs) # also GatingSets are S4 objects
Gate.Area <- rectangleGate(filterId = "Area", list("FSC-A" = c(FSC.A.low, FSC.A.high), "SSC-A" = c(SSC.A.low, SSC.A.high)))
# add the gate to the gs
add(gs, Gate.Area, parent = "root")
# gate the data
recompute(gs)
gatingStats <- gs.Stats(gs)
knitr::kable(gatingStats[[2]], caption = "after gate 1")
TrL <- FC.geom_hex(fs = getData(gs, "/Area"), x = "Pacific Blue-A", y = "FSC-A", bins = bins, co.fix = TRUE, xlimits = c(0.1, 300000), ylimits = c(.1,300000), trans = "log10", colPalette = NULL, ncolors = 10)
# - geom_point alternatives, are slower and with high enough bins FC.geom_hex contains almost all info -
# TrL_p <- FC.geom_point(fs = getData(gs, "/Area"), x = "Pacific Blue-A", y = "FSC-A", pch = ".", co.fix = TRUE, xlimits = c(0.1, 300000), ylimits = c(.1,300000), trans = "log10", nbin = 150)
# #
# # # -- even slower but with legend, so I prefer this point alternative --
# TrL_p <- FC.geom_point_kernel(fs = getData(gs, "/Area"), x = "Pacific Blue-A", y = "FSC-A", pch = ".", co.fix = TRUE, xlimits = c(0.1, 300000), ylimits = c(.1,300000), trans = "log10", colPalette = viridis, nbin = 70, ncolors = 10)
# # # ----
# --
#Poly <- data.frame(x = c(100, 15000, 15000, 2000, 800, 200), y = c(100, 100, 25000, 25000, 7000, 800))
TrL_Poly <- plotPolygon(TrL = TrL, polyDF = Poly)
TrL_Poly[[1]]
TrL_Poly[[2]]
TrL_Poly[[3]]
TrL_Poly[[7]]
TrL_Poly[[8]]
TrL_Poly[[9]]
TrL_Poly[[6]]
TrL_Poly[[8]]
TrL_Poly[[7]]
matr <- as.matrix(Poly)
colnames(matr) <- c("Pacific Blue-A", "FSC-A")
Gate.Poly <- polygonGate(matr, filterId = "Cells")
# add the gate to the gs
add(gs, Gate.Poly, parent = "/Area")
# gate the data
recompute(gs)
gatingStats <- gs.Stats(gs)
knitr::kable(gatingStats[[1]], caption = "after gate 2")
TrL_Poly[[10]]
TrL <- FC.geom_hex(fs = getData(gs, "/Area/Cells"), x = "FSC-A", y = "SSC-A", bins = bins, co.fix = TRUE, xlimits = c(0.1, 300000), ylimits = c(.1,300000), trans = "log10")
TrL[[1]]
TrL[[2]]
TrL[[3]]
TrL[[6]]
TrL[[7]]
TrL[[8]]
TrL <- FC.geom_hex(fs = getData(gs, "/Area/Cells"), x = "FSC-H", y = "SSC-H", bins = bins, co.fix = TRUE, xlimits = c(0.1, 300000), ylimits = c(.1,300000), trans = "log10")
TrL[[6]]
TrL[[7]]
TrL[[8]]
TrL[[8]] + geom_vline(xintercept = 800)
TrL[[7]] + geom_vline(xintercept = 800)
TrL[[7]] + geom_vline(xintercept = 900)
TrL[[6]] + geom_vline(xintercept = 900)
TrL[[7]] + geom_vline(xintercept = 800)
TrL[[8]] + geom_vline(xintercept = 800)
TrL[[9]] + geom_vline(xintercept = 850)
TrL[[10]] + geom_vline(xintercept = 850)
TrL_Poly[[10]]
TrL_Poly[[8]]
TrL_Poly[[6]]
TrL_Poly[[2]]
TrL_Poly[[1]]
TrL_Poly[[3]]
TrL_Poly[4]
TrL_Poly[[4]]
TrL <- FC.geom_hex(fs = getData(gs, "/Root"), x = "FSC-A", y = "SSC-A", bins = bins, co.fix = TRUE, xlimits = c(0.1, 300000), ylimits = c(.1,300000), trans = "log10")
TrL <- FC.geom_hex(fs = getData(gs, "/Area/Cells"), x = "FSC-H", y = "SSC-H", bins = bins, co.fix = TRUE, xlimits = c(0.1, 300000), ylimits = c(.1,300000), trans = "log10")
getNodes(gs)
TrL <- FC.geom_hex(fs = getData(gs, "/root"), x = "FSC-A", y = "SSC-A", bins = bins, co.fix = TRUE, xlimits = c(0.1, 300000), ylimits = c(.1,300000), trans = "log10")
TrL[[1]]
TrL[[2]]
TrL[[3]]
TrL[[4]]
TrL[[5]]
TrL[[6]]
TrL[[7]]
TrL[[8]]
TrL <- FC.geom_hex(fs = getData(gs, "/root"), x = "FSC-H", y = "SSC-H", bins = bins, co.fix = TRUE, xlimits = c(0.1, 300000), ylimits = c(.1,300000), trans = "log10")
TrL[[8]]
TrL[[7]]
TrL[[7]]
TrL[[7]] +geom_vline(xintercept = 850)
TrL[[7]] +geom_vline(xintercept = 1200)
TrL[[7]] +geom_vline(xintercept = 900)
